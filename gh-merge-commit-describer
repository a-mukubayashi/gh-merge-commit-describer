#!/usr/bin/env bash
set -e

echo "Hello gh-merge-commit-describer!?"

# Snippets to help get started:

# Check if the correct number of arguments is provided (expecting 1 argument)
if [ $# -ne 1 ]; then
  echo "Usage: gh pr-merge-commits PR_NUMBER"
  exit 1
fi

# Store the provided pull request number
pull_number=$1

# Get the repository information (owner and repository name) from the current directory's Git remote
repo_info=$(git config --get remote.origin.url | perl -ne 'print "$1/$2" if m{github.com[:/]([\w\-]+)/([\w\-]+)\.git}')
IFS="/" read -ra repo_parts <<< "$repo_info"

# Fetch the pull request ID and body using a GraphQL query
pr_query="{
  repository(owner: \"${repo_parts[0]}\", name: \"${repo_parts[1]}\") {
    pullRequest(number: $pull_number) {
      id
      body
    }
  }
}"
pr_response=$(gh api graphql -f query="$pr_query")

# Extract the pull request ID and body from the response
pr_id=$(echo "$pr_response" | jq -r '.data.repository.pullRequest.id')
pr_body=$(echo "$pr_response" | jq -r '.data.repository.pullRequest.body')

# Initialize variables for pagination
per_page=1
end_cursor=""

# Fetch all merge commits from the pull request using pagination
merge_commits=""
branch_name="develop"

echo "Branch name: $branch_name"
while true; do
  # Fetch commits with pagination using a GraphQL query
    QUERY="{
    repository(owner: \"${repo_parts[0]}\", name: \"${repo_parts[1]}\") {
      ref(qualifiedName: \"${branch_name}\") {
        target {
          ... on Commit {
            history(first: $per_page, after: \"$end_cursor\") {
              nodes {
                message
                oid
                parents(first: 2) {
                  totalCount
                }
                associatedPullRequests(first: 1) {
                  nodes {
                    number
                    labels(first: 10) {
                      nodes {
                        name
                        color
                      }
                    }
                    assignees(first: 10) {
                      nodes {
                        login
                      }
                    }
                  }
                }
              }
              pageInfo {
                endCursor
                hasNextPage
              }
            }
          }
        }
      }
    }
  }"
  #   QUERY="{
  #   repository(owner: \"${repo_parts[0]}\", name: \"${repo_parts[1]}\") {
  #     pullRequest(number: $pull_number) {
  #       commits(first: $per_page, after: \"$end_cursor\") {
  #         nodes {
  #           commit {
  #             messageHeadline
  #           }
  #         }
  #         pageInfo {
  #           endCursor
  #           hasNextPage
  #         }
  #       }
  #     }
  #   }
  # }"
  commits_response=$(gh api graphql -f query="$QUERY")
  echo '-------'

  merge_commit_node=$(echo "$commits_response" | jq '.data.repository.ref.target.history.nodes[] | select(.parents.totalCount == 2)')

  # echo $commits_response | jq .

  merge_commit_pr_number=$(echo "$merge_commit_node" | jq -r '.associatedPullRequests.nodes[0].number')

  # Check if there is a next page
  page_info=$(echo "$commits_response" | jq -r '.data.repository.ref.target.history.pageInfo')
  echo $page_info | jq .

  has_next_page=$(echo "$commits_response" | jq -r '.data.repository.ref.target.history.pageInfo.hasNextPage')
  if [ "$has_next_page" == "false" ]; then
    break
  fi

  # Update the end_cursor for the next iteration
  echo "End cursor: $end_cursor"
  end_cursor=$(echo "$commits_response" | jq -r '.data.repository.ref.target.history.pageInfo.endCursor')
done

# # Format the merge commits list with individual details and summary tags
# merge_commits_list=$(echo "$merge_commits" | jq -r '.[] | "- [ ] \(.messageHeadline)"')

# Update the pull request description with the merge commits list
# new_body="$pr_body

# $merge_commits_list
# "

# echo $new_body

# # Prepare the update mutation for the pull request body
# update_pr_mutation="mutation {
#   updatePullRequest(input: {pullRequestId: \"$pr_id\", body: \"\"\"$new_body\"\"\"}) {
#     clientMutationId
#   }
# }"

# # Execute the mutation to update the pull request body
# # gh api graphql -f query="$update_pr_mutation" --jq "."

# Print a success message
echo "Updated PR #$pull_number with merge commits"
